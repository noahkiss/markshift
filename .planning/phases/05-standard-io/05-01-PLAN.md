---
phase: 05-standard-io
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/cli/program.ts
  - src/cli/types.ts
  - src/cli/utils/format-detect.ts
  - src/cli/commands/convert.ts
  - src/cli/commands/html-to-md.ts
  - src/cli/commands/md-to-html.ts
  - tests/cli/format-detect.test.ts
  - tests/cli/convert.test.ts
  - tests/cli/json-output.test.ts
autonomous: true

must_haves:
  truths:
    - "User can pipe HTML via stdin and receive Markdown on stdout"
    - "User can pipe Markdown via stdin and receive HTML on stdout"
    - "Format is auto-detected when not explicitly specified"
    - "--json flag outputs structured result with metadata"
  artifacts:
    - path: "src/cli/utils/format-detect.ts"
      provides: "HTML vs Markdown format detection"
      exports: ["detectFormat"]
    - path: "src/cli/types.ts"
      provides: "JSON output type definitions"
      exports: ["JsonOutput", "GlobalOptions"]
    - path: "src/cli/commands/convert.ts"
      provides: "Auto-detect convert command"
      exports: ["convertCommand"]
  key_links:
    - from: "src/cli/commands/convert.ts"
      to: "src/cli/utils/format-detect.ts"
      via: "import detectFormat"
      pattern: "import.*detectFormat.*from.*format-detect"
    - from: "src/cli/program.ts"
      to: "src/cli/commands/convert.ts"
      via: "addCommand"
      pattern: "program\\.addCommand\\(convertCommand\\)"
    - from: "src/cli/commands/html-to-md.ts"
      to: "--json global option"
      via: "optsWithGlobals"
      pattern: "globalOpts\\.json"
---

<objective>
Enable pipeline usage with stdin/stdout and format auto-detection for markshift CLI.

Purpose: Allow markshift to function as a proper Unix-style pipeline tool where users can pipe content in, have the format auto-detected, and receive converted output without explicit format flags. Also provide machine-readable JSON output for scripting and agent integration.

Output:
- Format detection module (is-html based)
- New `convert` command with auto-detection
- Global `--json` flag for structured output
- Updated existing commands to support --json
- Comprehensive test suite
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-standard-io/05-RESEARCH.md
@src/cli/program.ts
@src/cli/commands/html-to-md.ts
@src/cli/commands/md-to-html.ts
@src/cli/utils/io.ts
@src/cli/utils/logger.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install is-html and create format detection module</name>
  <files>
    package.json
    src/cli/utils/format-detect.ts
    tests/cli/format-detect.test.ts
  </files>
  <action>
1. Install the is-html package:
   ```bash
   npm install is-html
   ```

2. Create `src/cli/utils/format-detect.ts`:
   - Import `isHtml` from 'is-html' (ESM: `import isHtml from 'is-html'`)
   - Import `Format` type from '../../types/index.js'
   - Export `detectFormat(content: string): Format` function:
     - Trim content, return 'text' if empty
     - Use isHtml() to check for HTML content
     - Return 'html' if HTML detected, 'markdown' otherwise
     - Do NOT attempt RTF detection (Phase 7 scope)
   - Add JSDoc documentation

3. Create `tests/cli/format-detect.test.ts`:
   - Test HTML detection: `<p>hello</p>`, `<div>content</div>`, `<!doctype html>`, `<html><body>test</body></html>`
   - Test Markdown fallback: `# Heading`, `**bold**`, `[link](url)`, plain text
   - Test edge cases: empty string, whitespace only, mixed content
   - Test that custom/unknown tags like `<cake>lie</cake>` are NOT detected as HTML (is-html behavior)
  </action>
  <verify>
    - `npm test -- tests/cli/format-detect.test.ts` passes
    - `npm run build` succeeds
    - Verify is-html is in package.json dependencies
  </verify>
  <done>
    - detectFormat() correctly identifies HTML content
    - detectFormat() returns 'markdown' for non-HTML text
    - Format detection tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add JSON output types and global --json flag</name>
  <files>
    src/cli/types.ts
    src/cli/program.ts
  </files>
  <action>
1. Create `src/cli/types.ts` with:
   ```typescript
   /**
    * CLI type definitions for JSON output and global options
    */

   /** Global options from parent command */
   export interface GlobalOptions {
     quiet?: boolean;
     verbose?: boolean;
     json?: boolean;
   }

   /** JSON output structure for machine-readable results */
   export interface JsonOutput {
     /** The converted content */
     content: string;
     /** Metadata about the conversion */
     metadata: {
       /** Detected or specified source format */
       sourceFormat: string;
       /** Target format of conversion */
       targetFormat: string;
       /** Processing time in milliseconds */
       processingTimeMs: number;
       /** Input character count */
       inputLength: number;
       /** Output character count */
       outputLength: number;
     };
   }

   /**
    * Create JSON output from conversion result
    */
   export function toJsonOutput(
     content: string,
     sourceFormat: string,
     targetFormat: string,
     processingTimeMs: number,
     inputLength: number
   ): JsonOutput {
     return {
       content,
       metadata: {
         sourceFormat,
         targetFormat,
         processingTimeMs,
         inputLength,
         outputLength: content.length,
       },
     };
   }
   ```

2. Update `src/cli/program.ts`:
   - Add `.option('--json', 'output results as JSON (for machine parsing)')` to program
   - Keep existing --quiet and --verbose options
  </action>
  <verify>
    - `npm run build` succeeds
    - `npm run cli -- --help` shows --json flag in output
  </verify>
  <done>
    - GlobalOptions interface includes json property
    - JsonOutput interface defined with content and metadata
    - toJsonOutput helper function created
    - --json global flag added to CLI program
  </done>
</task>

<task type="auto">
  <name>Task 3: Create convert command with auto-detection and update existing commands</name>
  <files>
    src/cli/commands/convert.ts
    src/cli/commands/html-to-md.ts
    src/cli/commands/md-to-html.ts
    src/cli/program.ts
    tests/cli/convert.test.ts
    tests/cli/json-output.test.ts
  </files>
  <action>
1. Create `src/cli/commands/convert.ts`:
   - Import Command from '@commander-js/extra-typings'
   - Import detectFormat from '../utils/format-detect.js'
   - Import readInput, writeOutput from '../utils/io.js'
   - Import createLogger from '../utils/logger.js'
   - Import both converters from '../../converters/...'
   - Import GlobalOptions, toJsonOutput from '../types.js'

   - Export `convertCommand`:
     - Command name: 'convert'
     - Description: 'Auto-detect format and convert (HTML to Markdown or Markdown to HTML)'
     - Argument: '[input]' - input file (stdin if omitted)
     - Option: '-o, --output <file>' - output file (stdout if omitted)
     - Option: '-t, --to <format>' - target format: md or html (auto-select if omitted)

   - Action handler:
     - Get globalOpts via `command.optsWithGlobals() as GlobalOptions`
     - Create logger with `globalOpts.quiet || globalOpts.json` (JSON mode suppresses logs)
     - Read input content
     - Detect format using detectFormat()
     - Log detected format (verbose)
     - Determine target format (explicit --to, or auto: html->md, markdown->html)
     - Select and run appropriate converter
     - Track start time with performance.now() for processingTimeMs
     - If --json: output JSON via `process.stdout.write(JSON.stringify(output, null, 2) + '\n')`
     - Else: use writeOutput() for normal text output
     - Handle errors with command.error()

2. Update `src/cli/commands/html-to-md.ts`:
   - Import GlobalOptions, toJsonOutput from '../types.js'
   - Replace local GlobalOptions interface with import
   - Update logger creation: `createLogger(globalOpts.quiet || globalOpts.json, globalOpts.verbose)`
   - Add timing with performance.now() before and after conversion
   - After conversion, check `if (globalOpts.json)`:
     - Create JsonOutput with toJsonOutput()
     - Write JSON to stdout: `process.stdout.write(JSON.stringify(jsonOutput, null, 2) + '\n')`
     - Return early (skip writeOutput)
   - Otherwise proceed with existing writeOutput logic

3. Update `src/cli/commands/md-to-html.ts`:
   - Same changes as html-to-md.ts
   - Import GlobalOptions, toJsonOutput from '../types.js'
   - Update logger, add timing, add JSON output branch

4. Update `src/cli/program.ts`:
   - Import convertCommand from './commands/convert.js'
   - Add `program.addCommand(convertCommand)` after existing commands

5. Create `tests/cli/convert.test.ts`:
   - Test auto-detection with HTML input -> Markdown output
   - Test auto-detection with Markdown input -> HTML output
   - Test explicit --to md flag
   - Test explicit --to html flag
   - Test stdin/stdout piping (mock process.stdin)
   - Test error handling for empty input

6. Create `tests/cli/json-output.test.ts`:
   - Test `markshift convert --json` with HTML input
   - Test `markshift convert --json` with Markdown input
   - Test `markshift html-to-md --json` output structure
   - Test `markshift md-to-html --json` output structure
   - Verify JSON has content and metadata fields
   - Verify metadata has sourceFormat, targetFormat, processingTimeMs, inputLength, outputLength
   - Verify JSON is valid (parseable)
   - Verify no extra console output when --json is active
  </action>
  <verify>
    - `npm run build` succeeds
    - `npm test` passes all tests
    - `echo '<p>test</p>' | npm run cli -- convert` outputs Markdown
    - `echo '# test' | npm run cli -- convert` outputs HTML
    - `echo '<p>test</p>' | npm run cli -- convert --json` outputs valid JSON
    - `echo '<p>test</p>' | npm run cli -- html-to-md --json` outputs valid JSON
    - `echo '# test' | npm run cli -- md-to-html --json` outputs valid JSON
    - JSON output can be piped to `jq` for parsing
  </verify>
  <done>
    - convert command auto-detects format and converts appropriately
    - convert command supports --to flag for explicit target format
    - All three commands (convert, html-to-md, md-to-html) support --json flag
    - JSON output includes content and metadata with all required fields
    - Logger output is suppressed when --json is active
    - All tests pass including new convert and JSON output tests
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Format Detection (IO-01, IO-02 partial, CONV-07)**
   ```bash
   # Verify HTML detection
   echo '<p>hello</p>' | npm run cli -- convert
   # Should output: hello

   # Verify Markdown detection
   echo '# Hello' | npm run cli -- convert
   # Should output: <h1>Hello</h1>
   ```

2. **Pipeline Usage (IO-01, IO-02)**
   ```bash
   # Full pipeline test
   echo '<div><p>Hello <strong>world</strong></p></div>' | npm run cli -- convert | npm run cli -- convert
   # Should round-trip (HTML -> MD -> HTML)
   ```

3. **JSON Output (IO-06)**
   ```bash
   # Verify JSON structure
   echo '<p>test</p>' | npm run cli -- convert --json | jq '.metadata'
   # Should show sourceFormat, targetFormat, processingTimeMs, etc.

   # Verify all commands support --json
   echo '<p>test</p>' | npm run cli -- html-to-md --json | jq '.content'
   echo '# test' | npm run cli -- md-to-html --json | jq '.content'
   ```

4. **All tests pass**
   ```bash
   npm test
   ```
</verification>

<success_criteria>
Phase 5 requirements satisfied:
- [IO-01] User can read input from stdin (convert command, existing commands)
- [IO-02] User can write output to stdout (convert command, existing commands)
- [IO-06] --json flag outputs structured JSON with content and metadata
- [CONV-07] Format is auto-detected as HTML or Markdown (RTF deferred to Phase 7)

Observable behaviors:
1. `echo '<p>test</p>' | markshift convert` produces Markdown output
2. `echo '# test' | markshift convert` produces HTML output
3. `markshift convert --json` outputs valid, parseable JSON
4. All three commands respect --json flag
5. All existing functionality (--quiet, --verbose, file I/O) continues to work
</success_criteria>

<output>
After completion, create `.planning/phases/05-standard-io/05-01-SUMMARY.md` using the summary template.

Update `.planning/STATE.md`:
- Phase: 5 of 9 (Standard I/O)
- Status: In progress -> Complete
- Add decisions: is-html for format detection, JSON envelope structure
</output>
