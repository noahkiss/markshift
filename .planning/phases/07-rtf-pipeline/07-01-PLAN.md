---
phase: 07-rtf-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/types/rtf-to-html.d.ts
  - src/converters/rtf-to-html/index.ts
  - src/converters/index.ts
  - src/cli/commands/convert.ts
  - tests/converters/rtf-to-html.test.ts
autonomous: true

must_haves:
  truths:
    - "User can convert RTF content to Markdown"
    - "RTF from macOS Notes/Word pastes convert correctly (bold, italic, links preserved)"
    - "RTF is processed via RTF->HTML->Markdown pipeline"
  artifacts:
    - path: "src/types/rtf-to-html.d.ts"
      provides: "TypeScript declarations for @iarna/rtf-to-html"
      contains: "declare module '@iarna/rtf-to-html'"
    - path: "src/converters/rtf-to-html/index.ts"
      provides: "RTF to HTML converter using pipeline pattern"
      exports: ["RtfToHtmlConverter"]
    - path: "tests/converters/rtf-to-html.test.ts"
      provides: "Unit tests for RTF conversion"
      min_lines: 50
  key_links:
    - from: "src/converters/rtf-to-html/index.ts"
      to: "@iarna/rtf-to-html"
      via: "promisified fromString"
      pattern: "promisify.*rtfToHtml"
    - from: "src/cli/commands/convert.ts"
      to: "src/converters/rtf-to-html/index.ts"
      via: "RtfToHtmlConverter import and usage"
      pattern: "RtfToHtmlConverter"
---

<objective>
Implement RTF to Markdown conversion via RTF->HTML->Markdown pipeline

Purpose: Enable clipboard RTF content (common from macOS Notes, Word, TextEdit) to convert to clean Markdown, completing the clipboard integration story started in Phase 6.

Output: RtfToHtmlConverter class, TypeScript declarations, CLI integration replacing the Phase 6 warning, and comprehensive tests.
</objective>

<execution_context>
@/home/flight/.claude/get-shit-done/workflows/execute-plan.md
@/home/flight/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-rtf-pipeline/07-RESEARCH.md

@src/converters/html-to-markdown/index.ts
@src/converters/index.ts
@src/cli/commands/convert.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependency and create TypeScript declarations</name>
  <files>package.json, src/types/rtf-to-html.d.ts</files>
  <action>
Install @iarna/rtf-to-html:
```bash
npm install @iarna/rtf-to-html
```

Create TypeScript declarations at src/types/rtf-to-html.d.ts:
```typescript
declare module '@iarna/rtf-to-html' {
  type TemplateFunction = (
    doc: unknown,
    defaults: unknown,
    content: string
  ) => string;

  interface Options {
    template?: TemplateFunction;
    paraBreaks?: string;
    paraTag?: string;
  }

  interface RtfToHtml {
    fromString(
      rtfString: string,
      options: Options | undefined,
      callback: (err: Error | null, html: string) => void
    ): void;
    fromString(
      rtfString: string,
      callback: (err: Error | null, html: string) => void
    ): void;
  }

  const rtfToHtml: RtfToHtml;
  export = rtfToHtml;
}
```
  </action>
  <verify>npm install completes without error; TypeScript compiles with new declarations</verify>
  <done>@iarna/rtf-to-html in dependencies; type declarations allow typed imports</done>
</task>

<task type="auto">
  <name>Task 2: Create RtfToHtmlConverter with pipeline pattern</name>
  <files>src/converters/rtf-to-html/index.ts</files>
  <action>
Create src/converters/rtf-to-html/index.ts:

1. Import rtfToHtml from '@iarna/rtf-to-html' and promisify it
2. Create RtfToHtmlConverter class implementing Converter interface
3. The convert method must be async (returns Promise<ConvertResult>)
4. Use the template option to extract body only: `template: (doc, defaults, content) => content`
5. Return ConvertResult with sourceFormat='rtf', targetFormat='html'

Key implementation details:
- Use `promisify` from 'node:util' to wrap callback-based API
- The library produces HTML fragments when using template option
- Track processingTimeMs for metadata
- Handle errors from the callback by letting promisify propagate them

Note: This converter outputs HTML, not Markdown. The CLI will chain this with HtmlToMarkdownConverter for the full RTF->MD pipeline.

Do NOT register this converter in the registry - it's an intermediate step used only by the CLI convert command.
  </action>
  <verify>TypeScript compiles; manual test with RTF string returns HTML</verify>
  <done>RtfToHtmlConverter class exists, exports correctly, converts RTF to HTML body fragment</done>
</task>

<task type="auto">
  <name>Task 3: Update CLI convert command to use RTF converter</name>
  <files>src/cli/commands/convert.ts</files>
  <action>
Update src/cli/commands/convert.ts to replace the RTF warning with actual conversion:

1. Import RtfToHtmlConverter from '../../converters/rtf-to-html/index.js'
2. In the RTF handling block (currently lines 41-43), replace the warning logic with:
   - Create RtfToHtmlConverter instance
   - Call `await rtfConverter.convert(content)` to get HTML
   - Pass the HTML to HtmlToMarkdownConverter
   - Set result to the Markdown output
   - Keep sourceFormat as 'rtf' for metadata (the input WAS rtf)

Before (current code):
```typescript
if (inputResult.sourceFormat === 'rtf') {
  logger.info('RTF detected. RTF-to-Markdown conversion coming in Phase 7. Using plain text for now.');
  sourceFormat = 'markdown'; // Treat RTF as plain text
}
```

After:
```typescript
if (inputResult.sourceFormat === 'rtf') {
  logger.verbose('RTF detected, converting via RTF->HTML->Markdown pipeline');
  const rtfConverter = new RtfToHtmlConverter();
  const htmlResult = await rtfConverter.convert(content);
  const mdConverter = new HtmlToMarkdownConverter();
  result = mdConverter.convert(htmlResult.content).content;
  sourceFormat = 'html'; // For auto-detection logic, but we already have result
  // Skip the normal conversion block below
}
```

Restructure the conversion logic so that when RTF is detected, it does the full pipeline and sets `result` directly, then skips the standard conversion block. The cleanest approach:
- After detecting RTF and doing the pipeline, set a flag or use early assignment
- The existing targetFormat/conversion logic should only run for non-RTF inputs
  </action>
  <verify>markshift convert --paste with RTF clipboard produces Markdown (not warning message)</verify>
  <done>RTF clipboard content converts to Markdown; no warning message appears; verbose mode shows pipeline info</done>
</task>

<task type="auto">
  <name>Task 4: Add tests for RTF converter and CLI integration</name>
  <files>tests/converters/rtf-to-html.test.ts</files>
  <action>
Create tests/converters/rtf-to-html.test.ts with comprehensive tests:

1. Basic RTF structure tests:
   - Simple text: `{\rtf1 Hello World}` should produce text
   - Bold: `{\rtf1 {\b bold text}}` should produce `<b>bold text</b>` or `<strong>`
   - Italic: `{\rtf1 {\i italic text}}` should produce `<i>italic text</i>` or `<em>`
   - Combined: bold + italic in same RTF

2. Metadata tests:
   - Returns sourceFormat='rtf', targetFormat='html'
   - Includes processingTimeMs >= 0

3. Edge cases:
   - Empty RTF: `{\rtf1}` should not throw
   - Invalid/malformed RTF should not crash (test graceful handling)

4. Real-world RTF samples (if available):
   - Test with RTF that looks like macOS clipboard output
   - Verify paragraph breaks convert properly

Sample RTF for testing:
```
{\rtf1\ansi\deff0 {\fonttbl {\f0 Times New Roman;}}
\pard Hello {\b bold} and {\i italic} text.\par
}
```

Use describe blocks organized by feature (similar to html-to-markdown.test.ts pattern).
Mark the describe as async since converter.convert() returns a Promise.
  </action>
  <verify>npm test passes; new RTF tests appear in output</verify>
  <done>RTF converter has test coverage; all tests pass; edge cases handled</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Unit tests pass:
   ```bash
   npm test
   ```

2. Manual RTF conversion works:
   ```bash
   echo '{\rtf1 Hello {\b bold} world}' | npx tsx src/cli/index.ts convert
   ```
   Should output Markdown with **bold** formatting

3. Clipboard RTF works (on macOS):
   - Copy styled text from Notes app
   - Run `markshift convert --paste`
   - Should get Markdown output (not warning message)

4. TypeScript compiles cleanly:
   ```bash
   npm run build
   ```
</verification>

<success_criteria>
- RTF input produces Markdown output via CLI
- No "Phase 7" warning message appears for RTF input
- Bold, italic, paragraph breaks preserved through pipeline
- All existing tests still pass (169+ tests)
- New RTF tests pass (expect ~180+ total)
</success_criteria>

<output>
After completion, create `.planning/phases/07-rtf-pipeline/07-01-SUMMARY.md`
</output>
