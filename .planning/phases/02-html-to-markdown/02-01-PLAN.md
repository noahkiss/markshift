---
phase: 02-html-to-markdown
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/converters/html-to-markdown/index.ts
  - src/converters/html-to-markdown/rules/code-language.ts
  - src/index.ts
  - tests/converters/html-to-markdown.test.ts
autonomous: true

must_haves:
  truths:
    - "User can convert HTML with headings, paragraphs, and emphasis to equivalent Markdown"
    - "User can convert HTML lists (ordered and unordered, nested) to Markdown"
    - "User can convert HTML links and images to Markdown syntax"
    - "User can convert HTML code blocks and inline code to Markdown with language hints preserved"
    - "User can convert HTML tables to Markdown tables"
    - "Malformed HTML does not crash the converter (graceful handling)"
    - "Whitespace in code blocks is preserved exactly"
    - "UTF-8 characters including emoji and CJK render correctly"
  artifacts:
    - path: "src/converters/html-to-markdown/index.ts"
      provides: "HtmlToMarkdownConverter class implementing Converter interface"
      exports: ["HtmlToMarkdownConverter"]
    - path: "src/converters/html-to-markdown/rules/code-language.ts"
      provides: "Custom turndown rule for extracting language from code blocks"
      exports: ["addCodeLanguageRule"]
    - path: "tests/converters/html-to-markdown.test.ts"
      provides: "Comprehensive test coverage for all HTML elements and edge cases"
      min_lines: 100
  key_links:
    - from: "src/converters/html-to-markdown/index.ts"
      to: "turndown"
      via: "import TurndownService"
      pattern: "import TurndownService from 'turndown'"
    - from: "src/converters/html-to-markdown/index.ts"
      to: "@truto/turndown-plugin-gfm"
      via: "import and use gfm plugin"
      pattern: "import.*gfm.*from '@truto/turndown-plugin-gfm'"
    - from: "src/converters/html-to-markdown/index.ts"
      to: "src/converters/index.ts"
      via: "implements Converter interface"
      pattern: "implements Converter"
    - from: "src/index.ts"
      to: "src/converters/html-to-markdown/index.ts"
      via: "re-export"
      pattern: "export.*from.*html-to-markdown"
---

<objective>
Implement HTML to Markdown converter using turndown with GFM support

Purpose: This is the core conversion capability - transforming HTML (from web pages, emails, Teams) into clean Markdown suitable for LLM processing and human readability.

Output: Working HtmlToMarkdownConverter class with full element support (headings, lists, links, images, tables, code blocks), custom language extraction for code blocks, and comprehensive test coverage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/02-html-to-markdown/02-RESEARCH.md
@src/types/index.ts
@src/converters/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install turndown dependencies</name>
  <files>package.json</files>
  <action>
Install the turndown ecosystem for HTML to Markdown conversion:

```bash
npm install turndown @truto/turndown-plugin-gfm
npm install -D @types/turndown
```

This adds:
- turndown v7.2.2: Core HTML to Markdown conversion with safe domino parser
- @truto/turndown-plugin-gfm v1.0.2: GFM tables, strikethrough, task lists (ESM-only, 20x faster tables)
- @types/turndown v5.0.6: TypeScript type definitions

Do NOT install JSDOM - turndown v7+ uses built-in domino parser which is faster and safer.
  </action>
  <verify>
```bash
npm ls turndown @truto/turndown-plugin-gfm @types/turndown
```
All three packages should be listed with their versions.
  </verify>
  <done>turndown, @truto/turndown-plugin-gfm, and @types/turndown installed in package.json</done>
</task>

<task type="auto">
  <name>Task 2: Implement HtmlToMarkdownConverter with custom language rule</name>
  <files>
    src/converters/html-to-markdown/index.ts
    src/converters/html-to-markdown/rules/code-language.ts
    src/index.ts
  </files>
  <action>
Create the HTML to Markdown converter:

**src/converters/html-to-markdown/rules/code-language.ts:**
```typescript
// Custom turndown rule to extract programming language from code block class attributes
// Common patterns: lang-js, language-javascript, highlight-source-python, hljs python
import type TurndownService from 'turndown';

const languagePatterns = [
  /\blang(?:uage)?-([a-z0-9_+-]+)\b/i,     // lang-js, language-javascript
  /\bhighlight-source-([a-z0-9_+-]+)\b/i,  // GitHub style
  /\bhljs\s+([a-z0-9_+-]+)\b/i,            // highlight.js style
  /\bsourceCode\s+([a-z0-9_+-]+)\b/i,      // pandoc style
];

function extractLanguage(node: Element): string {
  const targets = [node, node.parentElement].filter((n): n is Element => n !== null);

  for (const target of targets) {
    const className = target.className || '';
    for (const pattern of languagePatterns) {
      const match = className.match(pattern);
      if (match) return match[1].toLowerCase();
    }
  }
  return '';
}

export function addCodeLanguageRule(turndown: TurndownService): void {
  turndown.addRule('fencedCodeBlockWithLanguage', {
    filter: (node, options) => {
      return (
        options.codeBlockStyle === 'fenced' &&
        node.nodeName === 'PRE' &&
        node.firstChild !== null &&
        node.firstChild.nodeName === 'CODE'
      );
    },
    replacement: (_content, node, options) => {
      const codeNode = node.firstChild as Element;
      const language = extractLanguage(codeNode);
      const fence = options.fence || '```';
      // CRITICAL: Use textContent to preserve exact whitespace (indentation, newlines)
      const code = codeNode.textContent || '';

      return `\n\n${fence}${language}\n${code}\n${fence}\n\n`;
    },
  });
}
```

**src/converters/html-to-markdown/index.ts:**
```typescript
import TurndownService from 'turndown';
import { gfm } from '@truto/turndown-plugin-gfm';
import type { Converter, ConvertOptions, ConvertResult, Format } from '../../types/index.js';
import { addCodeLanguageRule } from './rules/code-language.js';

export class HtmlToMarkdownConverter implements Converter {
  readonly sourceFormat: Format = 'html';
  readonly targetFormat: Format = 'markdown';

  private turndown: TurndownService;

  constructor() {
    this.turndown = new TurndownService({
      headingStyle: 'atx',           // # style headings
      codeBlockStyle: 'fenced',      // ``` blocks
      fence: '```',
      emDelimiter: '_',              // _italic_
      strongDelimiter: '**',         // **bold**
      bulletListMarker: '-',         // - list items
      linkStyle: 'inlined',          // [text](url)
    });

    // Add GFM support (tables, strikethrough, task lists)
    this.turndown.use(gfm);

    // Add custom rule for language extraction from code blocks
    // Must be added AFTER gfm to override default code block handling
    addCodeLanguageRule(this.turndown);
  }

  convert(input: string, options?: ConvertOptions): ConvertResult {
    const startTime = performance.now();

    // Turndown's domino parser handles malformed HTML gracefully
    const content = this.turndown.turndown(input);

    const processingTimeMs = performance.now() - startTime;

    return {
      content,
      metadata: {
        sourceFormat: this.sourceFormat,
        targetFormat: this.targetFormat,
        processingTimeMs,
      },
    };
  }
}
```

**Update src/index.ts** to export the new converter:
```typescript
// Add export
export { HtmlToMarkdownConverter } from './converters/html-to-markdown/index.js';
```

Key implementation details:
- Uses turndown's built-in domino parser (no JSDOM needed)
- GFM plugin adds tables, strikethrough, task lists
- Custom rule extracts language from class attributes (lang-*, language-*, etc.)
- Uses textContent (not content param) to preserve whitespace in code blocks
- Implements existing Converter interface from Phase 1
  </action>
  <verify>
```bash
npx tsc --noEmit
```
TypeScript compiles without errors.
  </verify>
  <done>
HtmlToMarkdownConverter class created at src/converters/html-to-markdown/index.ts with:
- turndown configured with atx headings, fenced code blocks
- GFM plugin enabled for tables/strikethrough
- Custom code-language rule for language extraction
- Exported from src/index.ts
  </done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive test suite</name>
  <files>tests/converters/html-to-markdown.test.ts</files>
  <action>
Create test file covering all requirements (CONV-01 through CONV-05, CONV-10, QUAL-01 through QUAL-03):

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { HtmlToMarkdownConverter } from '../../src/converters/html-to-markdown/index.js';
import { registry } from '../../src/converters/index.js';

describe('HtmlToMarkdownConverter', () => {
  let converter: HtmlToMarkdownConverter;

  beforeEach(() => {
    converter = new HtmlToMarkdownConverter();
  });

  describe('CONV-01: semantic structure', () => {
    it('converts headings h1-h6 to atx style', () => {
      const html = '<h1>Title</h1><h2>Subtitle</h2><h3>Section</h3>';
      const result = converter.convert(html);
      expect(result.content).toContain('# Title');
      expect(result.content).toContain('## Subtitle');
      expect(result.content).toContain('### Section');
    });

    it('converts paragraphs', () => {
      const html = '<p>First paragraph.</p><p>Second paragraph.</p>';
      const result = converter.convert(html);
      expect(result.content).toContain('First paragraph.');
      expect(result.content).toContain('Second paragraph.');
    });

    it('converts emphasis (italic)', () => {
      const html = '<p>This is <em>emphasized</em> text.</p>';
      const result = converter.convert(html);
      expect(result.content).toContain('_emphasized_');
    });

    it('converts strong (bold)', () => {
      const html = '<p>This is <strong>bold</strong> text.</p>';
      const result = converter.convert(html);
      expect(result.content).toContain('**bold**');
    });

    it('converts nested emphasis', () => {
      const html = '<p><strong><em>bold and italic</em></strong></p>';
      const result = converter.convert(html);
      expect(result.content).toMatch(/\*\*_bold and italic_\*\*/);
    });
  });

  describe('CONV-02: lists', () => {
    it('converts unordered lists', () => {
      const html = '<ul><li>Item 1</li><li>Item 2</li></ul>';
      const result = converter.convert(html);
      expect(result.content).toContain('- Item 1');
      expect(result.content).toContain('- Item 2');
    });

    it('converts ordered lists', () => {
      const html = '<ol><li>First</li><li>Second</li></ol>';
      const result = converter.convert(html);
      expect(result.content).toContain('1. First');
      expect(result.content).toContain('2. Second');
    });

    it('converts nested lists', () => {
      const html = '<ul><li>Parent<ul><li>Child</li></ul></li></ul>';
      const result = converter.convert(html);
      expect(result.content).toContain('- Parent');
      expect(result.content).toContain('Child');
    });
  });

  describe('CONV-03: links and images', () => {
    it('converts links', () => {
      const html = '<a href="https://example.com">Example</a>';
      const result = converter.convert(html);
      expect(result.content).toBe('[Example](https://example.com)');
    });

    it('converts images', () => {
      const html = '<img src="image.png" alt="Alt text">';
      const result = converter.convert(html);
      expect(result.content).toBe('![Alt text](image.png)');
    });

    it('converts images without alt text', () => {
      const html = '<img src="image.png">';
      const result = converter.convert(html);
      expect(result.content).toContain('![](image.png)');
    });

    it('converts links containing images', () => {
      const html = '<a href="https://example.com"><img src="img.png" alt="Image"></a>';
      const result = converter.convert(html);
      expect(result.content).toContain('[![Image](img.png)](https://example.com)');
    });
  });

  describe('CONV-04: code blocks with language hints', () => {
    it('converts inline code', () => {
      const html = '<p>Use <code>const</code> for constants.</p>';
      const result = converter.convert(html);
      expect(result.content).toContain('`const`');
    });

    it('converts code blocks with lang-* class', () => {
      const html = '<pre><code class="lang-javascript">const x = 1;</code></pre>';
      const result = converter.convert(html);
      expect(result.content).toContain('```javascript');
      expect(result.content).toContain('const x = 1;');
      expect(result.content).toContain('```');
    });

    it('converts code blocks with language-* class', () => {
      const html = '<pre><code class="language-python">def hello():\n    pass</code></pre>';
      const result = converter.convert(html);
      expect(result.content).toContain('```python');
    });

    it('converts code blocks with highlight-source-* class', () => {
      const html = '<pre><code class="highlight-source-rust">fn main() {}</code></pre>';
      const result = converter.convert(html);
      expect(result.content).toContain('```rust');
    });

    it('converts code blocks without language class', () => {
      const html = '<pre><code>plain code</code></pre>';
      const result = converter.convert(html);
      expect(result.content).toContain('```\nplain code\n```');
    });
  });

  describe('CONV-05: tables', () => {
    it('converts simple tables', () => {
      const html = `
        <table>
          <thead><tr><th>Name</th><th>Age</th></tr></thead>
          <tbody><tr><td>Alice</td><td>30</td></tr></tbody>
        </table>
      `;
      const result = converter.convert(html);
      expect(result.content).toContain('| Name | Age |');
      expect(result.content).toContain('| --- | --- |');
      expect(result.content).toContain('| Alice | 30 |');
    });

    it('converts tables without thead', () => {
      const html = '<table><tr><td>A</td><td>B</td></tr></table>';
      const result = converter.convert(html);
      expect(result.content).toContain('|');
    });
  });

  describe('CONV-10: malformed HTML handling', () => {
    it('handles unclosed tags', () => {
      const html = '<p>Unclosed paragraph<p>Next paragraph</p>';
      expect(() => converter.convert(html)).not.toThrow();
    });

    it('handles mismatched tags', () => {
      const html = '<p><strong>Mismatched</p></strong>';
      expect(() => converter.convert(html)).not.toThrow();
    });

    it('handles empty input', () => {
      const result = converter.convert('');
      expect(result.content).toBe('');
    });

    it('handles plain text input', () => {
      const result = converter.convert('Just plain text');
      expect(result.content).toBe('Just plain text');
    });

    it('handles deeply nested elements', () => {
      const html = '<div><div><div><div><p>Deep</p></div></div></div></div>';
      expect(() => converter.convert(html)).not.toThrow();
      expect(converter.convert(html).content).toContain('Deep');
    });
  });

  describe('QUAL-01: whitespace preservation in code blocks', () => {
    it('preserves indentation in code blocks', () => {
      const code = 'function test() {\n    return true;\n}';
      const html = `<pre><code class="lang-javascript">${code}</code></pre>`;
      const result = converter.convert(html);
      expect(result.content).toContain('    return true;');
    });

    it('preserves multiple newlines in code blocks', () => {
      const code = 'line1\n\n\nline4';
      const html = `<pre><code>${code}</code></pre>`;
      const result = converter.convert(html);
      expect(result.content).toContain('line1\n\n\nline4');
    });

    it('preserves tabs in code blocks', () => {
      const code = 'line1\n\tindented';
      const html = `<pre><code>${code}</code></pre>`;
      const result = converter.convert(html);
      expect(result.content).toContain('\tindented');
    });
  });

  describe('QUAL-02: character encoding (UTF-8, emoji, CJK)', () => {
    it('handles emoji correctly', () => {
      const html = '<p>Hello üëã World üåç</p>';
      const result = converter.convert(html);
      expect(result.content).toContain('üëã');
      expect(result.content).toContain('üåç');
    });

    it('handles CJK characters', () => {
      const html = '<p>Êó•Êú¨Ë™û ‰∏≠Êñá ÌïúÍµ≠Ïñ¥</p>';
      const result = converter.convert(html);
      expect(result.content).toContain('Êó•Êú¨Ë™û');
      expect(result.content).toContain('‰∏≠Êñá');
      expect(result.content).toContain('ÌïúÍµ≠Ïñ¥');
    });

    it('handles special Unicode characters', () => {
      const html = '<p>Math: Œ± Œ≤ Œ≥ Œ¥ ‚àë ‚àè ‚àö</p>';
      const result = converter.convert(html);
      expect(result.content).toContain('Œ±');
      expect(result.content).toContain('‚àë');
    });
  });

  describe('QUAL-03: HTML entity decoding', () => {
    it('decodes common named entities', () => {
      const html = '<p>&lt;script&gt; &amp; &quot;quotes&quot;</p>';
      const result = converter.convert(html);
      expect(result.content).toContain('<script>');
      expect(result.content).toContain('&');
      expect(result.content).toContain('"quotes"');
    });

    it('decodes numeric entities', () => {
      const html = '<p>&#60;tag&#62; and &#x3C;hex&#x3E;</p>';
      const result = converter.convert(html);
      expect(result.content).toContain('<tag>');
      expect(result.content).toContain('<hex>');
    });

    it('decodes nbsp', () => {
      const html = '<p>Non&nbsp;breaking&nbsp;space</p>';
      const result = converter.convert(html);
      // nbsp becomes regular space in Markdown
      expect(result.content).toContain('Non');
      expect(result.content).toContain('breaking');
    });
  });

  describe('GFM features', () => {
    it('converts strikethrough', () => {
      const html = '<p><del>deleted</del> or <s>strikethrough</s></p>';
      const result = converter.convert(html);
      expect(result.content).toContain('~~deleted~~');
    });

    it('converts task lists', () => {
      const html = `
        <ul>
          <li><input type="checkbox" checked> Done</li>
          <li><input type="checkbox"> Todo</li>
        </ul>
      `;
      const result = converter.convert(html);
      expect(result.content).toContain('[x]');
      expect(result.content).toContain('[ ]');
    });
  });

  describe('metadata', () => {
    it('returns correct source and target formats', () => {
      const result = converter.convert('<p>Test</p>');
      expect(result.metadata?.sourceFormat).toBe('html');
      expect(result.metadata?.targetFormat).toBe('markdown');
    });

    it('includes processing time', () => {
      const result = converter.convert('<p>Test</p>');
      expect(result.metadata?.processingTimeMs).toBeGreaterThanOrEqual(0);
    });
  });

  describe('registry integration', () => {
    it('can be registered in the converter registry', () => {
      const localRegistry = registry;
      localRegistry.clear();
      localRegistry.register(converter);

      expect(localRegistry.has('html', 'markdown')).toBe(true);
      const retrieved = localRegistry.get('html', 'markdown');
      expect(retrieved).toBe(converter);
    });
  });
});
```

Test coverage requirements:
- CONV-01: headings, paragraphs, emphasis (5 tests)
- CONV-02: ordered, unordered, nested lists (3 tests)
- CONV-03: links, images, linked images (4 tests)
- CONV-04: inline code, code blocks with various language classes (5 tests)
- CONV-05: tables with/without thead (2 tests)
- CONV-10: malformed HTML, empty input, plain text (5 tests)
- QUAL-01: whitespace preservation in code (3 tests)
- QUAL-02: emoji, CJK, Unicode (3 tests)
- QUAL-03: HTML entities named, numeric, nbsp (3 tests)
- GFM: strikethrough, task lists (2 tests)
- Metadata: format info, timing (2 tests)
- Registry: integration (1 test)
  </action>
  <verify>
```bash
npm test
```
All tests pass.
  </verify>
  <done>
Test suite created at tests/converters/html-to-markdown.test.ts with:
- 38+ tests covering all requirements
- CONV-01 through CONV-05, CONV-10
- QUAL-01 through QUAL-03
- GFM features (strikethrough, task lists)
- Registry integration
- All tests passing
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Dependencies installed:**
   ```bash
   npm ls turndown @truto/turndown-plugin-gfm
   ```

2. **TypeScript compiles:**
   ```bash
   npx tsc --noEmit
   ```

3. **All tests pass:**
   ```bash
   npm test
   ```

4. **Manual verification (optional):**
   ```bash
   npx tsx -e "
   import { HtmlToMarkdownConverter } from './src/converters/html-to-markdown/index.js';
   const c = new HtmlToMarkdownConverter();
   console.log(c.convert('<h1>Test</h1><p>Hello <strong>world</strong></p>').content);
   "
   ```
   Should output:
   ```
   # Test

   Hello **world**
   ```
</verification>

<success_criteria>
Phase 2 is complete when:
- [ ] turndown and @truto/turndown-plugin-gfm installed
- [ ] HtmlToMarkdownConverter class exists at src/converters/html-to-markdown/index.ts
- [ ] Custom code language rule extracts lang-*, language-*, highlight-source-* patterns
- [ ] GFM plugin enabled for tables, strikethrough, task lists
- [ ] Converter exported from src/index.ts
- [ ] All 38+ tests pass covering CONV-01 through CONV-05, CONV-10, QUAL-01 through QUAL-03
- [ ] TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-html-to-markdown/02-01-SUMMARY.md`
</output>
