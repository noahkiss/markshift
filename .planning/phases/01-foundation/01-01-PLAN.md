---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - vitest.config.ts
  - src/index.ts
  - src/types/index.ts
  - src/converters/index.ts
  - tests/converters/registry.test.ts
autonomous: true

must_haves:
  truths:
    - "TypeScript compiles with zero errors in strict mode"
    - "npm test runs and all tests pass"
    - "Converter interface accepts input string and returns ConvertResult"
    - "Registry can register a converter and retrieve it by format pair"
  artifacts:
    - path: "package.json"
      provides: "Project configuration with ESM and scripts"
      contains: '"type": "module"'
    - path: "tsconfig.json"
      provides: "TypeScript strict mode configuration"
      contains: '"strict": true'
    - path: "vitest.config.ts"
      provides: "Test framework configuration"
      contains: "defineConfig"
    - path: "src/types/index.ts"
      provides: "Format type, ConvertOptions, ConvertResult interfaces"
      exports: ["Format", "ConvertOptions", "ConvertResult"]
    - path: "src/converters/index.ts"
      provides: "Converter interface and ConverterRegistry class"
      exports: ["Converter", "ConverterRegistry", "registry"]
    - path: "tests/converters/registry.test.ts"
      provides: "Registry unit tests"
      contains: "describe"
  key_links:
    - from: "src/converters/index.ts"
      to: "src/types/index.ts"
      via: "import { Format, ConvertOptions, ConvertResult }"
      pattern: "import.*from.*types"
    - from: "tests/converters/registry.test.ts"
      to: "src/converters/index.ts"
      via: "import { registry, Converter }"
      pattern: "import.*from.*converters"
---

<objective>
Set up TypeScript project structure and implement core converter abstractions.

Purpose: Establish the foundation that all subsequent phases depend on - a working TypeScript project with the Converter interface and Registry that future converters will implement and register with.

Output: A compilable TypeScript project with package.json, tsconfig.json, vitest.config.ts, core type definitions, Converter interface, ConverterRegistry class, and passing unit tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize TypeScript project with tooling</name>
  <files>
    package.json
    tsconfig.json
    vitest.config.ts
    src/index.ts
  </files>
  <action>
Create the TypeScript project foundation:

1. Create `package.json` with:
   - name: "markshift"
   - version: "0.0.1"
   - type: "module" (ESM)
   - main: "dist/index.js"
   - types: "dist/index.d.ts"
   - scripts: build (tsc), dev (tsx watch), test (vitest run), test:watch (vitest), typecheck (tsc --noEmit)
   - devDependencies: typescript ^5.9.0, vitest ^4.0.0, tsx ^4.21.0, @types/node ^25.0.0

2. Create `tsconfig.json` with strict mode settings from research:
   - target: ES2022
   - module: NodeNext
   - moduleResolution: NodeNext
   - strict: true
   - noUncheckedIndexedAccess: true
   - outDir: dist
   - rootDir: src
   - declaration: true, declarationMap: true, sourceMap: true
   - include: ["src/**/*"]
   - exclude: ["node_modules", "dist", "tests"]

3. Create `vitest.config.ts`:
   - include: ['tests/**/*.test.ts']
   - environment: 'node'
   - globals: false

4. Create directory structure:
   - src/
   - src/types/
   - src/converters/
   - src/cli/ (empty, for Phase 4)
   - tests/
   - tests/converters/

5. Create `src/index.ts` as main entry point that re-exports public API (placeholder for now, will export types and registry).

6. Run `npm install` to install dependencies.

7. Run `npx tsc --noEmit` to verify TypeScript configuration works.

Do NOT use ts-node (use tsx instead - faster). Do NOT use Jest (use Vitest). Do NOT use CommonJS (use ESM with type: module).
  </action>
  <verify>
- `npm install` completes without errors
- `npx tsc --noEmit` exits with code 0
- Directory structure exists: src/types/, src/converters/, src/cli/, tests/converters/
- package.json has "type": "module"
- tsconfig.json has "strict": true
  </verify>
  <done>
TypeScript project compiles successfully with strict mode enabled, all dependencies installed, directory structure in place.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement core types, Converter interface, and Registry</name>
  <files>
    src/types/index.ts
    src/converters/index.ts
    src/index.ts
    tests/converters/registry.test.ts
  </files>
  <action>
Implement the core abstractions from research patterns:

1. Create `src/types/index.ts` with:
   - `Format` type: union of 'html' | 'markdown' | 'rtf' | 'jira' | 'text'
   - `FormatPair` template literal type: `${Format}->${Format}`
   - `ConvertOptions` interface: { semantic?: boolean; rules?: Record<string, unknown>; }
   - `ConvertResult` interface: { content: string; metadata?: { sourceFormat: string; targetFormat: string; processingTimeMs?: number; }; }
   - `isValidFormat()` type guard function

2. Create `src/converters/index.ts` with:
   - Import types from '../types/index.js' (note .js extension for ESM)
   - `Converter` interface: { readonly sourceFormat: Format; readonly targetFormat: Format; convert(input: string, options?: ConvertOptions): ConvertResult; }
   - `ConverterRegistry` class with:
     - private converters Map<FormatPair, Converter>
     - register(converter: Converter): void - throws if already registered
     - get(source: Format, target: Format): Converter | undefined
     - has(source: Format, target: Format): boolean
     - list(): Array<{ source: Format; target: Format }>
   - Export singleton `registry` instance

3. Update `src/index.ts` to re-export:
   - All types from './types/index.js'
   - Converter, ConverterRegistry, registry from './converters/index.js'

4. Create `tests/converters/registry.test.ts` with tests:
   - Test: registry starts empty (list() returns empty array)
   - Test: can register a converter
   - Test: can retrieve registered converter by format pair
   - Test: has() returns true for registered, false for unregistered
   - Test: throws error when registering duplicate format pair
   - Test: get() returns undefined for unregistered format pair

Use Vitest imports: import { describe, it, expect, beforeEach } from 'vitest'
Create a fresh registry instance in beforeEach to avoid test pollution (or test the singleton behavior explicitly).

Do NOT make converters async. Do NOT use dependency injection frameworks. Do NOT put format detection logic here (that's Phase 5).
  </action>
  <verify>
- `npm run typecheck` passes (tsc --noEmit exits 0)
- `npm test` passes with all 6 registry tests green
- `src/types/index.ts` exports Format, ConvertOptions, ConvertResult, isValidFormat
- `src/converters/index.ts` exports Converter, ConverterRegistry, registry
- Registry can register and retrieve a mock converter
  </verify>
  <done>
Converter interface is defined. Registry can register converters and look them up by format pair. All unit tests pass via npm test.
  </done>
</task>

</tasks>

<verification>
Run these commands to verify phase completion:

```bash
# TypeScript compiles with strict mode
npm run typecheck

# All tests pass
npm test

# Build produces output
npm run build && ls dist/

# Verify exports work
node -e "import('./dist/index.js').then(m => console.log(Object.keys(m)))"
```

Expected: typecheck passes, 6+ tests pass, dist/ contains .js and .d.ts files, exports include Format, Converter, registry.
</verification>

<success_criteria>
1. TypeScript project compiles with strict mode (zero errors from tsc)
2. Converter interface is defined with sourceFormat, targetFormat, and convert() method
3. ConverterRegistry can register and lookup converters by format pair (html->markdown)
4. Unit tests run via `npm test` and all pass (6 tests minimum)
5. Project structure: src/types/, src/converters/, src/cli/, tests/converters/
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md` using the summary template.
</output>
