---
phase: 04-cli-framework
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/cli/index.ts
  - src/cli/program.ts
  - src/cli/commands/html-to-md.ts
  - src/cli/commands/md-to-html.ts
  - src/cli/utils/logger.ts
  - src/cli/utils/io.ts
  - tests/cli/cli.test.ts
autonomous: true

must_haves:
  truths:
    - "User can run markshift --help and see usage instructions"
    - "User can run markshift --version and see version number"
    - "User can run markshift html-to-md and convert HTML to Markdown"
    - "User can run markshift md-to-html and convert Markdown to HTML"
    - "--quiet flag suppresses non-essential output"
    - "--verbose flag shows detailed processing information"
    - "Exit code 0 on success, non-zero on error"
  artifacts:
    - path: "src/cli/index.ts"
      provides: "CLI entry point with shebang"
      contains: "#!/usr/bin/env node"
    - path: "src/cli/program.ts"
      provides: "Commander program definition"
      exports: ["run"]
    - path: "src/cli/commands/html-to-md.ts"
      provides: "HTML to Markdown subcommand"
      exports: ["htmlToMdCommand"]
    - path: "src/cli/commands/md-to-html.ts"
      provides: "Markdown to HTML subcommand"
      exports: ["mdToHtmlCommand"]
    - path: "src/cli/utils/logger.ts"
      provides: "Verbose/quiet aware logging"
      exports: ["createLogger", "Logger"]
    - path: "package.json"
      provides: "CLI bin configuration"
      contains: "\"bin\":"
  key_links:
    - from: "src/cli/program.ts"
      to: "src/cli/commands/html-to-md.ts"
      via: "addCommand(htmlToMdCommand)"
      pattern: "addCommand.*htmlToMdCommand"
    - from: "src/cli/commands/html-to-md.ts"
      to: "src/converters/html-to-markdown/index.ts"
      via: "HtmlToMarkdownConverter import"
      pattern: "HtmlToMarkdownConverter"
    - from: "package.json"
      to: "src/cli/index.ts"
      via: "bin field pointing to dist/cli/index.js"
      pattern: "\"markshift\".*cli/index.js"
---

<objective>
Implement the CLI framework for markshift using Commander.js, providing subcommands for HTML/Markdown conversion with --help, --version, --quiet, and --verbose flags.

Purpose: Enable command-line usage of markshift converters with standard CLI UX patterns. This is the first user-facing interface for the tool.

Output: Working CLI executable that can be run via `npx markshift` or after global install via `markshift`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-cli-framework/04-RESEARCH.md

@src/index.ts
@src/converters/html-to-markdown/index.ts
@src/converters/markdown-to-html/index.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Commander and create CLI infrastructure</name>
  <files>
    package.json
    src/cli/index.ts
    src/cli/program.ts
    src/cli/utils/logger.ts
    src/cli/utils/io.ts
  </files>
  <action>
1. Install dependencies:
   - `npm install commander`
   - `npm install -D @commander-js/extra-typings`

2. Create `src/cli/utils/logger.ts`:
   - Export `Logger` interface with `info()`, `verbose()`, `error()` methods
   - Export `createLogger(quiet?: boolean, verbose?: boolean)` factory
   - `info()` writes to stderr (so stdout stays clean for piping), suppressed by --quiet
   - `verbose()` writes to stderr with `[verbose]` prefix, only when --verbose AND NOT --quiet
   - `error()` always writes to stderr

3. Create `src/cli/utils/io.ts`:
   - Export `readInput(inputPath?: string): Promise<string>`:
     - If inputPath provided, read file with `fs/promises.readFile(inputPath, 'utf-8')`
     - If no inputPath, check `process.stdin.isTTY` - if true, throw helpful error
     - Otherwise read from stdin using async iterator
   - Export `writeOutput(outputPath: string | undefined, content: string): Promise<void>`:
     - If outputPath, write with `fs/promises.writeFile(outputPath, content, 'utf-8')`
     - Otherwise write to stdout with `process.stdout.write(content)`

4. Create `src/cli/program.ts`:
   - Import `Command` from `@commander-js/extra-typings`
   - Import `VERSION` from `../index.js`
   - Create program with:
     - `.name('markshift')`
     - `.description('Convert between HTML and Markdown formats')`
     - `.version(VERSION, '-v, --version', 'display version number')`
     - `.option('-q, --quiet', 'suppress all non-essential output')`
     - `.option('-V, --verbose', 'show detailed processing information')`
   - Export `async function run(argv: string[] = process.argv): Promise<void>` that calls `program.parseAsync(argv)`
   - Subcommands will be added in Task 2

5. Create `src/cli/index.ts` (entry point):
   - Add shebang: `#!/usr/bin/env node`
   - Import and call `run()` from `./program.js`
   - Catch errors and exit with code 1

6. Update `package.json`:
   - Add `"bin": { "markshift": "./dist/cli/index.js" }`
   - Add script `"cli": "tsx src/cli/index.ts"` for development testing

Use patterns from 04-RESEARCH.md exactly. Stderr for all non-data output is critical for pipe compatibility.
  </action>
  <verify>
    npm run build && npm run cli -- --help
    npm run cli -- --version
  </verify>
  <done>
    - `markshift --help` shows program description and global options
    - `markshift --version` shows "0.0.1"
    - Logger utility created with quiet/verbose support
    - I/O utilities created with stdin/stdout support
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement html-to-md and md-to-html subcommands</name>
  <files>
    src/cli/commands/html-to-md.ts
    src/cli/commands/md-to-html.ts
    src/cli/program.ts
  </files>
  <action>
1. Create `src/cli/commands/html-to-md.ts`:
   - Import `Command` from `@commander-js/extra-typings`
   - Import `HtmlToMarkdownConverter` from `../../converters/html-to-markdown/index.js`
   - Import `createLogger` from `../utils/logger.js`
   - Import `readInput`, `writeOutput` from `../utils/io.js`
   - Export `htmlToMdCommand`:
     ```typescript
     new Command('html-to-md')
       .description('Convert HTML to Markdown')
       .argument('[input]', 'input file path (reads from stdin if omitted)')
       .option('-o, --output <file>', 'output file path (writes to stdout if omitted)')
       .action(async (input, options, command) => {
         const globalOpts = command.optsWithGlobals();
         const logger = createLogger(globalOpts.quiet, globalOpts.verbose);

         try {
           logger.verbose('Starting HTML to Markdown conversion');
           const html = await readInput(input);
           logger.verbose(`Read ${html.length} characters of input`);

           const converter = new HtmlToMarkdownConverter();
           const result = converter.convert(html);

           logger.verbose(`Converted in ${result.metadata?.processingTimeMs}ms`);
           await writeOutput(options.output, result.content);

           if (options.output) {
             logger.info(`Written to ${options.output}`);
           }
         } catch (err) {
           const message = err instanceof Error ? err.message : String(err);
           command.error(`Conversion failed: ${message}`, { exitCode: 1 });
         }
       });
     ```

2. Create `src/cli/commands/md-to-html.ts`:
   - Same structure as html-to-md, but use `MarkdownToHtmlConverter`
   - Command name: `'md-to-html'`
   - Description: `'Convert Markdown to HTML'`

3. Update `src/cli/program.ts`:
   - Import both commands: `htmlToMdCommand`, `mdToHtmlCommand`
   - Add them with `program.addCommand(htmlToMdCommand)` and `program.addCommand(mdToHtmlCommand)`

4. Wire up error handling:
   - Use `command.error()` from Commander for all errors (provides consistent formatting and exit codes)
   - Wrap all I/O operations in try/catch
   - Include context in error messages (e.g., "Failed to read file 'foo.html': ENOENT")
  </action>
  <verify>
    echo "<h1>Test</h1>" | npm run cli -- html-to-md
    echo "# Test" | npm run cli -- md-to-html
    npm run cli -- html-to-md --help
    npm run cli -- md-to-html --help
  </verify>
  <done>
    - `echo "<h1>Test</h1>" | markshift html-to-md` outputs `# Test`
    - `echo "# Test" | markshift md-to-html` outputs `<h1>Test</h1>`
    - Subcommand --help shows command-specific options
    - --verbose shows processing details
    - --quiet suppresses info messages
  </done>
</task>

<task type="auto">
  <name>Task 3: Add CLI tests</name>
  <files>
    tests/cli/cli.test.ts
  </files>
  <action>
1. Create `tests/cli/cli.test.ts`:
   - Use Vitest's `describe`, `it`, `expect`
   - Import the `run` function from program to test CLI behavior
   - Use Commander's `exitOverride()` to throw instead of process.exit for testing
   - Mock stdout/stderr capture with `configureOutput()`

2. Test cases to implement:
   - **Help display**: `--help` includes program description and options
   - **Version display**: `--version` shows correct version
   - **Subcommand help**: `html-to-md --help` shows subcommand options
   - **HTML to Markdown conversion**: Valid HTML produces Markdown output
   - **Markdown to HTML conversion**: Valid Markdown produces HTML output
   - **Unknown command error**: Running unknown subcommand shows error
   - **Empty input error**: No stdin + no file argument + not TTY throws appropriate error

3. Test structure example:
   ```typescript
   import { describe, it, expect, beforeEach } from 'vitest';
   import { Command } from 'commander';

   // Test using a fresh Command instance with exitOverride
   describe('CLI', () => {
     let output: string[];
     let program: Command;

     beforeEach(() => {
       output = [];
       // Create program with test configuration
     });

     it('displays help with --help', () => {
       // Use exitOverride to catch help display
     });
   });
   ```

4. Note: Testing actual stdin is complex; focus on testing:
   - Command parsing and option handling
   - Error message formatting
   - Exit code expectations (via exitOverride throwing)
  </action>
  <verify>
    npm test -- --run tests/cli/
  </verify>
  <done>
    - All CLI tests pass
    - Tests cover help, version, subcommands, error handling
    - Test count reported in output
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Build and test
npm run build && npm test

# Manual CLI verification
npm run cli -- --help          # Shows usage with global options
npm run cli -- --version       # Shows 0.0.1
npm run cli -- html-to-md --help  # Shows html-to-md options

# Conversion tests
echo "<h1>Hello</h1><p>World</p>" | npm run cli -- html-to-md
# Expected: # Hello\n\nWorld

echo "# Hello\n\nWorld" | npm run cli -- md-to-html
# Expected: <h1>Hello</h1>\n<p>World</p>

# Verbose mode
echo "<h1>Test</h1>" | npm run cli -- html-to-md --verbose
# Expected: stderr shows [verbose] messages, stdout shows Markdown

# Quiet mode
echo "<h1>Test</h1>" | npm run cli -- html-to-md --quiet
# Expected: stdout only, no stderr

# Exit codes
npm run cli -- html-to-md nonexistent.html; echo "Exit code: $?"
# Expected: Error message and exit code 1
```
</verification>

<success_criteria>
1. `markshift --help` displays program description, version flag, global options (--quiet, --verbose), and available subcommands
2. `markshift --version` displays "0.0.1"
3. `markshift html-to-md` converts stdin HTML to stdout Markdown
4. `markshift md-to-html` converts stdin Markdown to stdout HTML
5. `markshift html-to-md input.html` reads from file
6. `markshift html-to-md -o output.md` writes to file
7. `--verbose` shows processing details to stderr
8. `--quiet` suppresses all non-data output
9. Invalid input or file not found produces actionable error message and exit code 1
10. All tests pass (existing + new CLI tests)
</success_criteria>

<output>
After completion, create `.planning/phases/04-cli-framework/04-01-SUMMARY.md` following the summary template.

Include:
- Dependency installation commands
- Key implementation patterns (Commander usage)
- Test results summary
- Verification evidence (CLI output screenshots)
</output>
